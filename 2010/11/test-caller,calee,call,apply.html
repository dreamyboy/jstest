<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>	<title></title>	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /></head><body>	<script type="text/javascript">		/**		 * 演示函数的caller属性.		 * 说明:(当前函数).caller:返回一个对函数的引用，该函数调用了当前函数         * 对于函数来说，caller 属性只有在函数执行时才有定义。如果函数是由顶层调用的，那么 caller 包含的就是 null 。         * 如果在字符串上下文中使用 caller 属性，那么结果和 functionName.toString 一样，也就是说，显示的是函数的反编译文本		 */		function callerDemo(){			if(callerDemo.caller){				var a = callerDemo.caller.arguments[0];				alert(a);			} else {				alert('this is a top function!!');			}		};//		callerDemo(1, 3);		function handleCaller(){			callerDemo();		}		handleCaller('1', '2');				/**		 * 演示函数的callee属性.		 * 说明:arguments.callee:初始值就是正被执行的 Function 对象,用于匿名函数         * callee 属性是 arguments 对象的一个成员，它表示对函数对象本身的引用，这有利于匿名函数的递归或者保证函数的封装性		 */		function calleeDemo(){			alert(arguments.callee);		}//		calleeDemo(1, 2);		//形参的个数		//(function(arg0, arg1){			//alert('形参的个数为： ' + arguments.callee.length);		//})();				/**		 * 演示apply,call函数的用法		 * 说明:作用都是将函数绑定到另外一个对象上去运行，两者仅在定义参数方式有所区别：		 *       apply(thisArg,argArray);		 *     call(thisArg[,arg1,arg2…] ]);		 *     即所有函数内部的this指针都会被赋值为thisArg		 */		function ObjectA(){			alert('执行ObjectA');			alert(arguments[0]);			this.hit = function(msg){ alert(msg); };			this.info = '我来自ObjectA';		}				function ObjectB(){			alert('执行ObjectB');			//ObjectA.apply(this, arguments); 			ObjectA.call(this);			alert(this.info);		}		//ObjectB('a');				var value = 'global变量';		function Obj(){			this.value = '对象';		}		function fun1(){					}	</script></body></html>