<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>	<title></title>	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /></head><body>	<script type="text/javascript">		/*		var fn1 = function(){			var v1 = 100;			this.temp = 200;			return v1 + this.temp;		}		//alert(typeof fn1);		//alert(fn1());		//alert(fn1.constructor());				var fn2 = new function(){			var v1 = 100;			this.temp = 200;			return v1 + this.temp;		}		alert(typeof fn2);		alert(fn2.constructor());				var fn1 = new function(){ return '圆心'; }		alert(fn1);		//alert(typeof fn1);		var fn2 = new function(){ return new String('圆心'); };		alert(fn2);		alert(typeof fn2);		//只要 new 表达式之后的 constructor 返回（return）一个引用对象（数组，对象，函数等），		//都将覆盖new创建的匿名对象，如果返回（return）一个原始类型（无 return 时其实为 return 原始类型 undefined），		//那么就返回 new 创建的匿名对象		//由于 new String 会构造一个对象，而不是一个 string 直接量，且new String(x) 如果带参数，		//那么alert它的时候就会返回 x。所以 yx01 将返回 new String(”圆心”) 这个对象，而 alert yx01 则显示 “圆心”。 				//如果function的返回值是对象的话则返回该对象，否则返回function的实例		function fn(){			this.k = 1;			return Number(1);		}		fn.prototype = {			j:0		};		var f = new fn();		alert(f);				function fn(s){			this.method();			alert(s);		}		fn.prototype.method = function(){ alert('sss') };		var f = new fn('test');		alert(f.constructor());				new function(){			this.a = 'aa';			alert(this.a);		};		(function(){			this.a = 'aa';			alert(this.a);		})();				Date.prototype.age = 12;		var d1 = new Date();		d1.prototype.age = 22;		alert(d1.age);		*/		var obj = {};		//alert(obj.prototype); //undefined 因为我们不能通过对象的实例跟上prototype关键字来访问属性		//alert(Object.prototype);		alert(obj.prototype.constructor);	</script></body></html>