<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>	<title></title>	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /></head><body>	form:http://www.cnblogs.com/mrsunny/archive/2011/05/09/2041185.html	<script type="text/javascript">		function Circel(radius){			this.r = radius;			this.des = '圆形';			this.showInfo = function(){				alert('这是一个' + this.des);			}		}		function Circel_area(){ return Circel.PI * this.r * this.r; }		function Circel_perimeter(r){ return 2 * Circel.PI * r; }		Circel.PI = 3.14;		Circel.perimeter = Circel_perimeter;		Circel.prototype.area = Circel_area;				var c = new Circel(3);		//c.des = '直角';		//console.log(Circel.PI);		//console.log(c.PI); //类属性与函数本身关联，与实例没有关系		//var p = c.constructor.PI;		//console.log(c.constructor.PI); //对象或属性不支持此方法。因为perimeter函数是Circle类的类方法，和实例对象没有直接关系		//console.log(Circel.des); //因为函数Circle函数中的this.des中的this指代的不是函数本身，而是调用r的对象，而且只能是对象。		//console.log(c.des);		//console.log(c.constructor.des);		/*结论：  		 *面向对象的角度：类属性是类对象的直接属性，且该属性与基于该类对象生成的实例对象没有直接关系，无法直接调用。  		 *可以直接通过 类名.属性名 调用该类属性。如果想通过该类对象的实例对象调用类属性，那么可以使用 对象实例.constructor属性  		 *调用该对象的类对象，然后通过类对象调用其类属性  		 *javascript函数角度：类属性是javascript函数对象的直接属性变量（这里之所以称之为属性变量是由于javascript变量和属性的同一性），		 *且该属性变量与基于该函数对象构造出来的对象引用（生成了一个对象，这个对象实际上是一个空对象，并且保存了对构造  		 *函数以及构造函数初始化时函数内部this关键字下的相关属性和函数的引用[c.prototype和构造函数中this.下面的相关属性、函数]：）  		 *没有直接关系，如果想通过基于构造函数生成的对象c调用构造函数对象的属性变量PI，那么需要通过c.constructor属性找到该构造  	     *函数对象，并通过该对象获取其属性变量。      		 */		 //alert(c.constructor.perimeter(3)); //调用该对象构造函数（类函数）的方法（函数）。		 //alert(c.area(3)); //Circle类的prototype原型属性下的area方法将会被Circle类的实例对象继承。		//console.log(c.prototype); //undefined 实例对象没有ptototype属性		//console.log(Circel.prototype);		//alert(Circel.prototype.constructor); )//返回Circle的函数体（函数代码体），相当于alert(Circle)		//alert(Circel);		//console.log(Circel.prototype.area(3));//NaN 方法调用成功，但是返回结果却是NaN，原因是area函数内部的this.r是undefined。								/*结论：prototype原型对象是javascript基于原型链表实现的一个重要属性。         Javascript角度：         1. 实例对象没有prototype属性，只有构造函数才有prototype属性，也就是说构造函数本身保存了对prototype属性         的引用。。         2. prototype属性对象有一个constructor属性，保存了引用他自己的构造函数的引用（看起来像是个循环：A指向B，B指向A...）         3.prototype对象（不要被我这里的属性对象，对象，对象属性搞晕乎了，说是属性对象，就是说当前这个东西他首先是某个对象的属性，         同时自己也是个对象。对象属性就是说它是某个对象的属性。）的属性变量和属性对象将会被该prototype对象引用的构造函数所创建的         对象继承(function A(){} A.prototype.pa = function(){} var oA = new A(); 那么oA将会继承属性函数pa)。         */		//alert(c.__proto__);		//alert(c.__proto__.PI);//undefined 因为函数原型下面没有PI属性，PI是类函数Circle的直接属性		//alert(c.__proto__.area(3));//NaN 该函数执行成功，返回值为NaN是由于函数体中的this.r为undefined。		/*结论：__proto__属性保存了对创建该对象的构造函数引用prototype属性的引用，也就是说构造函数可以引用prototype，基于该构  		  造函数生成的实例也可以引用，只不过引用的方式不一样。		*/				var foo = function(){}		foo.prototype.method = function() {			alert('a');		}		var f = new foo();		f.method();		//new foo().method()			</script></body></html>