<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>	<title></title>	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" /></head><body>	<script type="text/javascript">		/*		var Test = function(){			this.arr = []; //原理很简单，初始化的时候使当前实例（this）的arr(数组)属性（来源于对象原型:Test）从新指向空数组		}		Test.prototype = {			arr:[] ////使分别两次实例化的时候具有两个arr(数组)，但是注意是指向同一个内存位置		}		var test1 = new Test();		test1.arr.push('ddd');		var test2 = new Test();		alert(test2.arr);		*/		var Test = function(string){			var privateArg = '豪情';						this.publicString = string;			this.publicArr = [];			this.publicFunction = function(){				alert('I\'m the public function');			}		}		Test.prototype = {			staticString: 'static',			staticArr:[],			staticFunction: function(){				Test.prototype.staticString = 'alreadySetByFunc';			}		}				var test1 = new Test('p1');		Test.prototype.staticString = 's1'; //通过原型类更改静态属性staticString		//alert(test1.staticString);		var test2 = new Test('p2');		//test2.staticFunction();		//alert(test2.staticString);		test2.staticString = 's2';		//alert(test1.staticString);		test1.staticArr.push('a2');		//alert(test2.staticArr);		//为什么原型类的静态数组属性也发生改变了！？原因很简单：实际上实例化的时候新的实例实际上复制了原型类的静态属性和方法，而数组的复制，		//大家知道，实际上只是指向的复制，所以当任意一方对数据修改，其他引用到该数组的地方都会发生改变。				//Test.publicFunction(); //对于Test方法类并没有公有的publicFunction方法，重点在理解this,在没有被实例化的时候this指的是window		test1.publicFunction(); //在实例化的时候新的实例被初始化一个publicFunction方法		test1.publicArr.push('newArr');		alert(test2.publicArr);	</script></body></html>